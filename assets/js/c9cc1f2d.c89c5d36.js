"use strict";(globalThis.webpackChunkspeediful_docs=globalThis.webpackChunkspeediful_docs||[]).push([[9846],{331:(e,n,i)=>{i.d(n,{Ay:()=>r,RM:()=>o});var t=i(4848),s=i(8453);const o=[];function a(e){const n={code:"code",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Every data load operation results in the following columns being added to the input table:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SLAM_Message"})," - the end result of the operation: ",(0,t.jsx)(n.code,{children:"'Operation Successful.'"})," or an error message return by Salesforce"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SLAM_unique_id"})," (as needed) - a generated unique identifier if there is no available key column in the input table"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The two ",(0,t.jsx)(n.code,{children:"SLAM_*"})," fields are not loaded into the Salesforce object, but as responses are received from Salesforce, the ",(0,t.jsx)(n.code,{children:"SLAM_*"})," fields are populated and the ",(0,t.jsx)(n.code,{children:"Id"})," column is written with the Salesforce Id from the response."]})]})}function r(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},2105:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>u,frontMatter:()=>l,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"load-operations/Loading Data","title":"Loading Data","description":"Overview","source":"@site/docs/load-operations/Loading Data.md","sourceDirName":"load-operations","slug":"/load-operations/Loading Data","permalink":"/load-operations/Loading Data","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Load Operations","permalink":"/category/load-operations"},"next":{"title":"NULL and Blank Handling","permalink":"/load-operations/NULL and Blank Handling"}}');var s=i(4848),o=i(8453),a=i(5046),r=i(331);const l={},d="Loading Data",c={},h=[{value:"Overview",id:"overview",level:2},{value:"General Requirements for Loading Data",id:"general-requirements-for-loading-data",level:2},...a.RM,{value:"Effect of Load Operations",id:"effect-of-load-operations",level:2},...r.RM,{value:"Field Mapping",id:"field-mapping",level:2},{value:"Dual Relationship Syntax Support",id:"dual-relationship-syntax-support",level:2},{value:"Client-side Disconnections",id:"client-side-disconnections",level:2},{value:"A brief overview of the APIs",id:"a-brief-overview-of-the-apis",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"loading-data",children:"Loading Data"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["Speediful provides data loading capabilties via SOAP, Bulk v1 and Bulk v2 APIs. A unified interface is provided by the procedure ",(0,s.jsx)(n.a,{href:"/load-operations/SLAM_load",children:(0,s.jsx)(n.code,{children:"SLAM_load"})})," which requires an ",(0,s.jsx)(n.code,{children:"@api"})," parameter. Alternatively, users can directly call the various ",(0,s.jsx)(n.code,{children:"SLAM_load_<api_name>"}),". All operations are logged to ",(0,s.jsx)(n.code,{children:"SLAM_Activity_Log"})]}),"\n",(0,s.jsx)(n.h2,{id:"general-requirements-for-loading-data",children:"General Requirements for Loading Data"}),"\n","\n",(0,s.jsx)(a.Ay,{}),"\n",(0,s.jsx)(n.h2,{id:"effect-of-load-operations",children:"Effect of Load Operations"}),"\n","\n",(0,s.jsx)(r.Ay,{}),"\n",(0,s.jsx)(n.h2,{id:"field-mapping",children:"Field Mapping"}),"\n",(0,s.jsx)(n.p,{children:"Speediful automatically maps fields to Salesforce when the SQL column name matches an eligible field API name. Eligible fields will depend on the operation being performed (insert, update, delete, etc). Fields that exist in the input table but do not exist in the Salesforce target will be ignored and logged to the program's output without raising an error."}),"\n",(0,s.jsx)(n.p,{children:"A common problem is that Salesforce fields do not get populated as expected even if they exist in the input table. This is usually caused by incomplete field level security configuration, where the user performing the data load does not have edit access to the fields that need to be populated."}),"\n",(0,s.jsx)(n.h2,{id:"dual-relationship-syntax-support",children:"Dual Relationship Syntax Support"}),"\n",(0,s.jsx)(n.p,{children:"Speediful supports two relationship naming styles for upsert operations:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"RelationshipName.Field"})," (Salesforce standard style)","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The RelationshipName is defined within the Salesforce API and can be found in the ",(0,s.jsx)(n.code,{children:"[part.RelationshipName]"})," column of the ",(0,s.jsxs)("a",{href:"../Metadata%20Operations/SLAM_sObject_fields.mdx",children:[(0,s.jsx)(n.code,{children:"sObject_fields_*"})," table"]})]}),"\n",(0,s.jsxs)(n.li,{children:["Examples: ",(0,s.jsx)(n.code,{children:"Owner.Username"})," and ",(0,s.jsx)(n.code,{children:"Contact_Lookup__r.External_Id__c"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"FieldApiName.Field"})," (DBAmp compatibility style)","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Speediful supports this naming style as a developer aid/convenience. Speediful automatically translates them into the RelationshipName style supported by Salesforce"}),"\n",(0,s.jsxs)(n.li,{children:["Examples: ",(0,s.jsx)(n.code,{children:"OwnerId.Username"})," and ",(0,s.jsx)(n.code,{children:"Contact_Lookup__c.External_Id__c"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"client-side-disconnections",children:"Client-side Disconnections"}),"\n",(0,s.jsx)(n.p,{children:"SOAP operations require a continuous, uninterrupted connection with the Salesforce server while data is transferred in batches. Disconnections for any reason (server crash, network interruption, etc) can result in an inconsistent state between the database and Salesforce for the in-progress batch. A manual true-up of data would be required in this scenario."}),"\n",(0,s.jsxs)(n.p,{children:["Salesforce has designed the Bulk APIs to be asynchronous, which means that once the dataset has been transferred to Salesforce, an ongoing connection with Salesforce is not required. If a disconnection occurs after the data has been transferred to Salesforce, the result of the completed Salesforce processing can be retrieved using ",(0,s.jsx)(n.a,{href:"/utility-functions/SLAM_download_job",children:"SLAM_download_job"})]}),"\n",(0,s.jsx)(n.h2,{id:"a-brief-overview-of-the-apis",children:"A brief overview of the APIs"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Bulk v1 API"})," provides the highest level of control over large data loads, including batch sizes and serial vs parallel processing. Bulk v1 supports hardDelete. Note that Salesforce specifically ",(0,s.jsx)(n.a,{href:"https://help.salesforce.com/s/articleView?id=platform.fields_caf_requirements.htm&type=5",children:"has not validated Bulk v1 for use with custom address fields"})," and therefore you should look to Bulk v2 in those situations"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Bulk v2 API"})," provides a simplified approach to large data loads, allowing Salesforce to take a determining role in the orchestration of the job. Bulk v2 supports hardDelete"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"SOAP API"})," is suited to smaller volumes of records and provides additional controls via header options (see SOAP Headers section). SOAP is the only API to support undelete"]}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},5046:(e,n,i)=>{i.d(n,{Ay:()=>r,RM:()=>o});var t=i(4848),s=i(8453);const o=[];function a(e){const n={admonition:"admonition",code:"code",p:"p",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["The input table should have an Id column defined as an ",(0,t.jsx)(n.code,{children:"NCHAR(18)"})," or ",(0,t.jsx)(n.code,{children:"NVARCHAR(18)"})," to receive the Salesforce Id returned by Salesforce."]}),"\n",(0,t.jsx)(n.admonition,{type:"important",children:(0,t.jsxs)(n.p,{children:["When loading data to Salesforce, if the ",(0,t.jsx)(n.code,{children:"SLAM_Message"})," column exists, Speediful ignores any records in the input table where ",(0,t.jsx)(n.code,{children:"SLAM_Message = 'Operation Successful.'"}),". This allows the same input table to be re-run after a partial failure as it will simply ignore any rows that were previously successful.  This approach makes it simple for users to correct data issues in-situ without risk of creating duplicate records, while also keeping Salesforce data processing volumes efficient"]})})]})}function r(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>r});var t=i(6540);const s={},o=t.createContext(s);function a(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);